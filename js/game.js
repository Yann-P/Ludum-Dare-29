// Generated by CoffeeScript 1.7.1
(function() {
  var handleCollision, randomFloatBetween,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ld.Entity = (function() {
    function Entity(kind, pos, size) {
      this.kind = kind || ld.ENTITY.UNKNOWN;
      this.level = null;
      this.game = null;
      this.pos = pos || new Vec2();
      this.size = size || new Vec2();
      this.vel = new Vec2();
      this.hitbox = new Rectangle();
      this.spawnAt = Date.now();
      this.random = ~~(Math.random() * 200);
      this.lifeTime = -1;
      this.angle = 0;
      this.collidable = false;
      this.currentAnim = null;
      this.animations = {};
      this.friction = .9;
      this.restitution = 0;
      this.wallCollisionCallback = null;
    }

    Entity.prototype.update = function() {
      if (this.lifeTime !== -1) {
        if (Date.now() - this.spawnAt > this.lifeTime) {
          this.remove();
        }
      }
      if (isNaN(this.vel.y || isNaN(this.pos.y || isNaN(this.vel.x || isNaN(this.pos.x))))) {
        throw new Error("Fatal error Not A Number");
      }
      if (this.collidable) {
        this.level.forEachOfKind(ld.ENTITY.WALL, (function(_this) {
          return function(wall) {
            var blockX, blockY, collision;
            collision = wall.collides(_this);
            blockX = false;
            blockY = false;
            if (collision) {
              if (_this.wallCollisionCallback != null) {
                _this.wallCollisionCallback();
              }
              if (_this.vel.x > 0 && wall.pos.x > _this.pos.x) {
                blockX = true;
              } else if (_this.vel.x < 0 && wall.pos.x + wall.hitbox.width < _this.pos.x + _this.hitbox.width) {
                blockX = true;
              }
              if (_this.vel.y > 0 && wall.pos.y > _this.pos.y) {
                blockY = true;
              } else if (_this.vel.y < 0 && wall.pos.y + wall.hitbox.height < _this.pos.y + _this.hitbox.height) {
                blockY = true;
              }
            }
            if (blockY) {
              _this.vel.y *= -_this.restitution;
            }
            if (blockX) {
              return _this.vel.x *= -_this.restitution;
            }
          };
        })(this));
      }
      this.pos.x += this.vel.x;
      this.pos.y += this.vel.y;
      this.vel.x *= this.friction;
      this.vel.y *= this.friction;
      if (this.currentAnim != null) {
        return this.currentAnim.update();
      }
    };

    Entity.prototype.draw = function(ctx) {
      ctx.save();
      ctx.translate(this.game.ssx, this.game.ssy);
      if (this.currentAnim) {
        ctx.save();
        ctx.translate(this.pos.x + this.size.x * .5, this.pos.y + this.size.y * .5);
        ctx.rotate(this.angle);
        ctx.translate(-(this.pos.x + this.size.x * .5), -(this.pos.y + this.size.y * .5));
        this.currentAnim.draw(ctx, this.pos);
        ctx.restore();
      }
      if (ld.DEBUG) {
        if (this.hitbox) {
          ctx.strokeStyle = 'red';
          ctx.strokeRect(this.pos.x + this.hitbox.x, this.pos.y + this.hitbox.y, this.hitbox.width, this.hitbox.height);
        }
      }
      return ctx.restore();
    };

    Entity.prototype.collides = function(entity) {
      var r1, r2;
      if (!(entity.hitbox instanceof Rectangle)) {
        throw new Error("L'entité " + entity + " n'a pas de hitbox de type Rectangle");
      }
      if (!(this.hitbox instanceof Rectangle)) {
        throw new Error("L'entité " + entity + " n'a pas de hitbox de type Rectangle");
      }
      r1 = new Rectangle(this.pos.x + this.hitbox.x + this.vel.x, this.pos.y + this.hitbox.y + this.vel.y, this.hitbox.width, this.hitbox.height);
      r2 = new Rectangle(entity.pos.x + entity.hitbox.x + entity.vel.x, entity.pos.y + entity.hitbox.y + entity.vel.y, entity.hitbox.width, entity.hitbox.height);
      return r1.collides(r2);
    };

    Entity.prototype.onWallCollision = function(callback) {
      return this.wallCollisionCallback = callback;
    };

    Entity.prototype.addAnim = function(animid, frameTime, sequence) {
      if (!this.animSheet) {
        throw new Error("AnimSheet non définie");
      }
      return this.animations[animid] = new ld.Anim(animid, this.animSheet, frameTime, sequence);
    };

    Entity.prototype.setAnim = function(animid) {
      if (this.currentAnim && this.currentAnim.animid === animid) {
        return;
      }
      return this.currentAnim = this.animations[animid];
    };

    Entity.prototype.setGame = function(game) {
      return this.game = game;
    };

    Entity.prototype.setLevel = function(level) {
      return this.level = level;
    };

    Entity.prototype.remove = function() {
      this.level.unregisterEntity(this);
      return delete this;
    };

    return Entity;

  })();

  ld.Powerup = (function(_super) {
    __extends(Powerup, _super);

    function Powerup(kind, pos, size) {
      Powerup.__super__.constructor.call(this, kind, pos, size);
    }

    Powerup.prototype.update = function() {
      this.vel.y = Math.sin((Date.now() + this.random) / 100) / 3;
      this.angle = this.vel.y / 5;
      return Powerup.__super__.update.call(this);
    };

    return Powerup;

  })(ld.Entity);

  ld.WeaponLoot = (function(_super) {
    __extends(WeaponLoot, _super);

    function WeaponLoot(kind, pos) {
      var size, spriteName;
      size = kind === ld.ENTITY.BASICGUN_LOOT ? new Vec2(30, 30) : kind === ld.ENTITY.LASERGUN_LOOT ? new Vec2(54, 27) : kind === ld.ENTITY.FIREBALL_LAUNCHER_LOOT ? new Vec2(36, 35) : void 0;
      WeaponLoot.__super__.constructor.call(this, kind, pos, size);
      this.hitbox = new Rectangle(7, 7, 20, 20);
      spriteName = kind === ld.ENTITY.BASICGUN_LOOT ? 'basicgun' : kind === ld.ENTITY.LASERGUN_LOOT ? 'lasergun' : kind === ld.ENTITY.FIREBALL_LAUNCHER_LOOT ? 'fireball-launcher' : void 0;
      this.animSheet = new ld.AnimSheet('assets/' + spriteName + '.png', this.size);
      this.addAnim('default', 1000, [[0, 0]]);
      this.setAnim('default');
    }

    WeaponLoot.prototype.update = function() {
      if (this.level.player.collides(this)) {
        if (this.level.player.weapon1 != null) {
          this.level.player.weapon1.remove();
        }
        this.level.player.weapon1 = this.kind === ld.ENTITY.BASICGUN_LOOT ? new ld.Basicgun(this.pos.copy()) : this.kind === ld.ENTITY.LASERGUN_LOOT ? new ld.Lasergun(this.pos.copy()) : this.kind === ld.ENTITY.FIREBALL_LAUNCHER_LOOT ? new ld.FireballLauncher(this.pos.copy()) : void 0;
        this.level.registerEntity(this.level.player.weapon1);
        this.remove();
      }
      return WeaponLoot.__super__.update.call(this);
    };

    return WeaponLoot;

  })(ld.Powerup);

  ld.SmallPotion = (function(_super) {
    __extends(SmallPotion, _super);

    function SmallPotion(kind, pos) {
      SmallPotion.__super__.constructor.call(this, kind, pos, new Vec2(27, 30));
      this.hitbox = new Rectangle(7, 7, 20, 20);
      this.animSheet = new ld.AnimSheet('assets/small-potion.png', this.size);
      this.addAnim('health', 1000, [[0, 0]]);
      this.addAnim('speed', 1000, [[0, 1]]);
      this.addAnim('strength', 1000, [[0, 2]]);
      this.setAnim(this.kind === ld.ENTITY.SMALL_HEALTH_POTION ? 'health' : this.kind === ld.ENTITY.SMALL_SPEED_POTION ? 'speed' : this.kind === ld.ENTITY.SMALL_STRENGTH_POTION ? 'strength' : void 0);
    }

    SmallPotion.prototype.update = function() {
      if (this.level.player.collides(this)) {
        if (this.kind === ld.ENTITY.SMALL_HEALTH_POTION) {
          this.level.player.health += 2;
          this.level.player.health = Math.min(10, this.level.player.health);
        } else if (this.kind === ld.ENTITY.SMALL_SPEED_POTION) {
          this.level.player.speedBoost(5000);
        } else if (this.kind === ld.ENTITY.SMALL_STRENGTH_POTION) {
          this.level.player.strengthBoost(10000);
        }
        this.remove();
      }
      return SmallPotion.__super__.update.call(this);
    };

    return SmallPotion;

  })(ld.Powerup);

  ld.BigPotion = (function(_super) {
    __extends(BigPotion, _super);

    function BigPotion(kind, pos) {
      BigPotion.__super__.constructor.call(this, kind, pos, new Vec2(33, 33));
      this.hitbox = new Rectangle(7, 7, 20, 20);
      this.animSheet = new ld.AnimSheet('assets/big-potion.png', this.size);
      this.addAnim('health', 1000, [[0, 0]]);
      this.addAnim('speed', 1000, [[0, 1]]);
      this.addAnim('strength', 1000, [[0, 2]]);
      this.setAnim(this.kind === ld.ENTITY.BIG_HEALTH_POTION ? 'health' : this.kind === ld.ENTITY.BIG_SPEED_POTION ? 'speed' : this.kind === ld.ENTITY.BIG_STRENGTH_POTION ? 'strength' : void 0);
    }

    BigPotion.prototype.update = function() {
      if (this.level.player.collides(this)) {
        if (this.kind === ld.ENTITY.BIG_HEALTH_POTION) {
          this.level.player.health += 5;
          this.level.player.health = Math.min(10, this.level.player.health);
        } else if (this.kind === ld.ENTITY.BIG_SPEED_POTION) {
          this.level.player.speedBoost(20000);
        } else if (this.kind === ld.ENTITY.BIG_STRENGTH_POTION) {
          this.level.player.strengthBoost(30000);
        }
        this.remove();
      }
      return BigPotion.__super__.update.call(this);
    };

    return BigPotion;

  })(ld.Powerup);

  ld.Teleporter = (function(_super) {
    __extends(Teleporter, _super);

    function Teleporter(pos, size, levelid, coords) {
      Teleporter.__super__.constructor.call(this, ld.ENTITY.TELEPORTER, pos, size);
      this.hitbox = new Rectangle(0, 0, this.size.x, this.size.y);
      this.levelid = levelid;
      this.coords = coords;
    }

    Teleporter.prototype.update = function() {
      if (this.level.player.collides(this) && (this.level.isCleared() || ld.DEBUG)) {
        if (this.coords != null) {
          this.level.player.pos = this.coords.copy();
        }
        this.game.loadLevel(this.levelid);
        return this.remove();
      }
    };

    Teleporter.prototype.draw = function(ctx) {
      ctx.globalAlpha = (Math.sin(Date.now() / 200) + 1) / 2;
      ctx.fillStyle = 'white';
      if (this.level.player.collides(this) && !this.level.isCleared()) {
        ctx.fillStyle = 'red';
      }
      ctx.fillRect(this.pos.x, this.pos.y, this.size.x, this.size.y);
      return ctx.globalAlpha = 1;
    };

    return Teleporter;

  })(ld.Entity);

  randomFloatBetween = function(min, max) {
    return Math.random() * (max - min) + min;
  };

  ld.Particle = (function(_super) {
    __extends(Particle, _super);

    function Particle(pos, options) {
      if ((options != null) && (options.size != null)) {
        this.size = new Vec2(options.size, options.size);
      } else {
        this.size = new Vec2(2, 2);
      }
      Particle.__super__.constructor.call(this, ld.ENTITY.PARTICLE, pos, this.size);
      this.hitbox = new Rectangle(0, 0, 2, 2);
      this.collidable = options.collidable || true;
      this.color = options.color || 'red';
      this.range = options.range || [[-2, 2], [-2, 2]];
      this.friction = options.friction || 1;
      this.restitution = options.restitution || 1;
      this.lifeTime = options.lifeTime || -1;
      this.opacityLoss = options.opacityLoss || 0;
      this.opacity = 1;
      this.vel = new Vec2(randomFloatBetween(this.range[0][0], this.range[0][1]), randomFloatBetween(this.range[1][0], this.range[1][1]));
    }

    Particle.prototype.update = function() {
      this.opacity -= this.opacityLoss;
      return Particle.__super__.update.call(this);
    };

    Particle.prototype.draw = function(ctx) {
      ctx.globalAlpha = this.opacity < 0 ? 0 : this.opacity;
      ctx.fillStyle = this.color;
      ctx.fillRect(this.pos.x, this.pos.y, this.size.x, this.size.y);
      return ctx.globalAlpha = 1;
    };

    Particle.sendParticles = function(level, amount, pos, options) {
      var i, particle, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= amount ? _i < amount : _i > amount; i = 0 <= amount ? ++_i : --_i) {
        particle = new ld.Particle(pos.copy(), options);
        _results.push(level.registerEntity(particle));
      }
      return _results;
    };

    return Particle;

  })(ld.Entity);

  ld.Wall = (function(_super) {
    __extends(Wall, _super);

    function Wall(pos, size) {
      Wall.__super__.constructor.call(this, ld.ENTITY.WALL, pos, size);
      this.hitbox = new Rectangle(0, 0, this.size.x, this.size.y);
    }

    Wall.prototype.draw = function(ctx) {
      ctx.fillStyle = 'black';
      ctx.lineWidth = 10;
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.strokeRect(this.pos.x, this.pos.y, this.size.x, this.size.y);
      ctx.fillRect(this.pos.x, this.pos.y, this.size.x, this.size.y);
      ctx.lineWidth = 1;
      return Wall.__super__.draw.call(this, ctx);
    };

    return Wall;

  })(ld.Entity);

  ld.Weapon = (function(_super) {
    __extends(Weapon, _super);

    function Weapon(kind, pos, size, spriteName, spriteOffset, cooldown) {
      Weapon.__super__.constructor.call(this, kind, pos, size);
      this.spriteOffset = spriteOffset;
      this.cooldown = cooldown;
      this.lastShot = new Date(0);
      this.animSheet = new ld.AnimSheet('assets/' + spriteName + '.png', this.size);
      this.addAnim('right', 1000, [[0, 0]]);
      this.addAnim('left', 1000, [[0, 1]]);
      this.setAnim('right');
    }

    Weapon.prototype.canShoot = function() {
      return Date.now() - this.lastShot > this.cooldown;
    };

    Weapon.prototype.shoot = function() {
      return this.lastShot = Date.now();
    };

    Weapon.prototype.update = function() {
      this.setAnim(this.level.player.orientation);
      if (this.level.player.orientation === ld.ORIENTATION.LEFT) {
        this.angle = this.game.mousePos.getAngle(this.pos) + 0.0174532925 * 180;
      } else {
        this.angle = this.game.mousePos.getAngle(this.pos);
      }
      return Weapon.__super__.update.call(this);
    };

    Weapon.prototype.draw = function(ctx) {
      ctx.save();
      if (this.level.player.orientation === ld.ORIENTATION.RIGHT) {
        ctx.translate(this.spriteOffset.x, this.spriteOffset.y);
      } else {
        ctx.translate(-this.spriteOffset.x + this.level.player.size.x - this.size.x, this.spriteOffset.y);
      }
      Weapon.__super__.draw.call(this, ctx);
      return ctx.restore();
    };

    return Weapon;

  })(ld.Entity);

  ld.Basicgun = (function(_super) {
    __extends(Basicgun, _super);

    function Basicgun(pos) {
      Basicgun.__super__.constructor.call(this, ld.ENTITY.BASICGUN, pos, new Vec2(30, 30), 'basicgun', new Vec2(-5, -5), 500);
    }

    Basicgun.prototype.shoot = function(angle) {
      if (this.canShoot()) {
        this.level.registerEntity(new ld.Flame(this.pos.copy(), angle, 7));
        return Basicgun.__super__.shoot.call(this);
      }
    };

    return Basicgun;

  })(ld.Weapon);

  ld.Lasergun = (function(_super) {
    __extends(Lasergun, _super);

    function Lasergun(pos) {
      Lasergun.__super__.constructor.call(this, ld.ENTITY.LASERGUN, pos, new Vec2(54, 27), 'lasergun', new Vec2(20, 10), 200);
    }

    Lasergun.prototype.shoot = function(angle) {
      if (this.canShoot()) {
        this.level.registerEntity(new ld.Laser(this.pos.copy(), angle, 25));
        return Lasergun.__super__.shoot.call(this);
      }
    };

    return Lasergun;

  })(ld.Weapon);

  ld.FireballLauncher = (function(_super) {
    __extends(FireballLauncher, _super);

    function FireballLauncher(pos) {
      FireballLauncher.__super__.constructor.call(this, ld.ENTITY.FIREBALL_LAUNCHER, pos, new Vec2(36, 35), 'fireball-launcher', new Vec2(10, 5), 200);
    }

    FireballLauncher.prototype.shoot = function(angle) {
      if (this.canShoot()) {
        this.level.registerEntity(new ld.Fireball(this.pos.copy(), angle, 15));
        return FireballLauncher.__super__.shoot.call(this);
      }
    };

    return FireballLauncher;

  })(ld.Weapon);

  ld.Projectile = (function(_super) {
    __extends(Projectile, _super);

    function Projectile(kind, pos, size, spriteName, angle, power, damage) {
      Projectile.__super__.constructor.call(this, kind, pos, size);
      this.collidable = true;
      this.angle = angle;
      this.damage = damage;
      this.friction = 0.99;
      this.restitution = 0.9;
      this.vel = new Vec2(Math.cos(angle) * power, Math.sin(angle) * power);
      this.animSheet = new ld.AnimSheet('assets/' + spriteName + '.png', this.size);
      this.addAnim('default', 1000, [[0, 0]]);
      this.setAnim('default');
    }

    Projectile.prototype.update = function() {
      this.angle = Math.atan2(this.pos.y - this.pos.y + this.vel.y, this.pos.x - this.pos.x + this.vel.x);
      return Projectile.__super__.update.call(this);
    };

    return Projectile;

  })(ld.Entity);

  ld.Fireball = (function(_super) {
    __extends(Fireball, _super);

    function Fireball(pos, angle, power) {
      Fireball.__super__.constructor.call(this, ld.ENTITY.FIREBALL, pos, new Vec2(36, 21), 'fireball', angle, power, 3);
      this.hitbox = new Rectangle(10, 10, 10, 10);
      this.lifeTime = 1000;
    }

    return Fireball;

  })(ld.Projectile);

  ld.BossProjectile = (function(_super) {
    __extends(BossProjectile, _super);

    function BossProjectile(pos, angle, power) {
      BossProjectile.__super__.constructor.call(this, ld.ENTITY.BOSS_PROJECTILE, pos, new Vec2(13, 13), 'boss-projectile', angle, power, 1);
      this.hitbox = new Rectangle(0, 0, 13, 13);
      this.lifeTime = 5000;
      this.friction = 1;
      this.collidable = true;
    }

    BossProjectile.prototype.update = function() {
      if (this.collides(this.level.player)) {
        this.level.player.damage(1);
      }
      return BossProjectile.__super__.update.call(this);
    };

    return BossProjectile;

  })(ld.Projectile);

  ld.Flame = (function(_super) {
    __extends(Flame, _super);

    function Flame(pos, angle, power) {
      Flame.__super__.constructor.call(this, ld.ENTITY.FIREBALL, pos, new Vec2(27, 12), 'flame', angle, power, 1);
      this.hitbox = new Rectangle(10, 10, 10, 10);
      this.lifeTime = 2000;
      this.onWallCollision((function(_this) {
        return function() {
          return ld.Particle.sendParticles(_this.level, 10, _this.pos.copy(), ld.PARTICLE.BASICGUN);
        };
      })(this));
    }

    return Flame;

  })(ld.Projectile);

  ld.Laser = (function(_super) {
    __extends(Laser, _super);

    function Laser(pos, angle, power) {
      Laser.__super__.constructor.call(this, ld.ENTITY.FIREBALL, pos, new Vec2(30, 15), 'laser', angle, power, 1);
      this.hitbox = new Rectangle(0, 0, 30, 15);
      this.lifeTime = 1000;
    }

    return Laser;

  })(ld.Projectile);

  ld.Character = (function(_super) {
    __extends(Character, _super);

    Character.HEART = new ld.AnimSheet('assets/heart.png');

    Character.HALF_HEART = new ld.AnimSheet('assets/half-heart.png');

    function Character(kind, pos, size, health, speed) {
      Character.__super__.constructor.call(this, kind, pos, size);
      this.orientation = ld.ORIENTATION.RIGHT;
      this.health = health;
      this.speed = speed || 1;
      this.collidable = true;
    }

    Character.prototype.damage = function(amount) {
      this.health -= amount;
      this.health = Math.max(this.health, 0);
      if (this.health <= 0) {
        return this.die();
      }
    };

    Character.prototype.die = function() {
      return this.remove();
    };

    Character.prototype.drawHeart = function(ctx, x, y, half) {
      if (half) {
        return ctx.drawImage(ld.Character.HALF_HEART.image, x, y);
      } else {
        return ctx.drawImage(ld.Character.HEART.image, x, y);
      }
    };

    Character.prototype.update = function() {
      if (Math.abs(this.vel.x) > 0.1 || Math.abs(this.vel.y) > 0.1) {
        this.setAnim('run_' + this.orientation);
      } else {
        this.setAnim('idle_' + this.orientation);
      }
      return Character.__super__.update.call(this);
    };

    Character.prototype.draw = function(ctx) {
      var health, x, y;
      health = this.health || 0;
      x = this.pos.x + this.size.x / 2 - health * 5;
      y = this.pos.y - 15;
      while (health !== 0) {
        if (health >= 2) {
          this.drawHeart(ctx, x, y, false);
          x += 18;
          health -= 2;
        } else {
          this.drawHeart(ctx, x, y, true);
          x += 10;
          health--;
        }
      }
      return Character.__super__.draw.call(this, ctx);
    };

    return Character;

  })(ld.Entity);

  handleCollision = function(e1, e2) {
    var angle;
    angle = e1.pos.getAngle(e2.pos);
    if (!(e1 instanceof ld.Boss)) {
      e1.vel.x = Math.cos(angle) * e1.speed;
      e1.vel.y = Math.sin(angle) * e1.speed;
    }
    if (!(e2 instanceof ld.Boss)) {
      e2.x = Math.sin(angle) * e2.speed;
      return e2.y = Math.cos(angle) * e2.speed;
    }
  };

  ld.Monster = (function(_super) {
    __extends(Monster, _super);

    function Monster(kind, pos, size, health, strength, speed) {
      Monster.__super__.constructor.call(this, kind, pos, size, health, speed);
      this.tracking = true;
      this.strength = strength;
      this.shadowEffectSpeed = ~~(Math.random() * 5) + 5;
      this.shadowEffectStart = ~~(Math.random() * 3000) + 100;
      this.speed += Math.random();
    }

    Monster.prototype.draw = function(ctx) {
      return Monster.__super__.draw.call(this, ctx);
    };

    Monster.prototype.die = function() {
      ld.Particle.sendParticles(this.level, 7, this.pos.copy(), ld.PARTICLE.MOBDEATH);
      return Monster.__super__.die.call(this);
    };

    Monster.prototype.update = function() {
      if (this.pos.x + this.hitbox.width < 0 || this.pos.y + this.hitbox.height < 0 || this.pos.x + this.hitbox.width > this.game.width || this.pos.y + this.hitbox.height > this.game.height) {
        return this.remove();
      }
      if (this.vel.x === 0) {
        this.vel.y *= 4;
      }
      if (this.vel.y === 0) {
        this.vel.x *= 4;
      }
      if (this.level.player.collides(this)) {
        this.level.player.damage(this.strength);
      }
      this.level.forEachMonster((function(_this) {
        return function(monster) {
          _this.tracking = true;
          if (monster !== _this && monster.collides(_this)) {
            _this.tracking = false;
            return handleCollision(_this, monster);
          }
        };
      })(this));
      this.level.forEachProjectile((function(_this) {
        return function(projectile) {
          if (projectile.kind !== ld.ENTITY.BOSS_PROJECTILE && projectile.collides(_this)) {
            _this.damage(projectile.damage);
            return projectile.remove();
          }
        };
      })(this));
      this.orientation = this.level.player.pos.x > this.pos.x ? ld.ORIENTATION.RIGHT : this.orientation = ld.ORIENTATION.LEFT;
      return Monster.__super__.update.call(this);
    };

    return Monster;

  })(ld.Character);

  ld.Shadow1 = (function(_super) {
    __extends(Shadow1, _super);

    function Shadow1(pos) {
      Shadow1.__super__.constructor.call(this, ld.ENTITY.SHADOW1, pos, new Vec2(30, 30), 4, 1, 1);
      this.hitbox = new Rectangle(10, 10, this.size.x - 10, this.size.y - 10);
      this.animSheet = new ld.AnimSheet('assets/shadow1.png', this.size);
      this.addAnim('idle_right', 100, [[0, 0]]);
      this.addAnim('idle_left', 100, [[0, 1]]);
      this.addAnim('run_right', 100, [[0, 0], [1, 0], [2, 0]]);
      this.addAnim('run_left', 100, [[0, 1], [1, 1], [2, 1]]);
      this.setAnim('run_right');
    }

    Shadow1.prototype.update = function() {
      var angle;
      if (this.tracking && this.level.player.pos.getDistance(this.pos) > 20) {
        angle = this.level.player.pos.getAngle(this.pos);
        this.vel.x = Math.cos(angle) * this.speed;
        this.vel.y = Math.sin(angle) * this.speed;
      }
      return Shadow1.__super__.update.call(this);
    };

    return Shadow1;

  })(ld.Monster);

  ld.Shadow2 = (function(_super) {
    __extends(Shadow2, _super);

    function Shadow2(pos) {
      Shadow2.__super__.constructor.call(this, ld.ENTITY.SHADOW1, pos, new Vec2(48, 42), 7, 2, 2);
      this.hitbox = new Rectangle(10, 10, this.size.x - 10, this.size.y - 10);
      this.animSheet = new ld.AnimSheet('assets/shadow2.png', this.size);
      this.addAnim('idle_right', 100, [[0, 0]]);
      this.addAnim('idle_left', 100, [[0, 1]]);
      this.addAnim('run_right', 100, [[0, 0], [1, 0], [2, 0]]);
      this.addAnim('run_left', 100, [[0, 1], [1, 1], [2, 1]]);
      this.setAnim('run_right');
    }

    Shadow2.prototype.update = function() {
      var angle;
      if (this.tracking && this.level.player.pos.getDistance(this.pos) > 20) {
        angle = this.level.player.pos.getAngle(this.pos);
        if (this.vel.x !== 0 && this.vel.y !== 0) {
          angle += 20;
        }
        this.vel.x = Math.cos(angle) * this.speed;
        this.vel.y = Math.sin(angle) * this.speed;
      }
      return Shadow2.__super__.update.call(this);
    };

    return Shadow2;

  })(ld.Monster);

  ld.Shadow3 = (function(_super) {
    __extends(Shadow3, _super);

    function Shadow3(pos) {
      Shadow3.__super__.constructor.call(this, ld.ENTITY.SHADOW3, pos, new Vec2(42, 60), 12, 4, 3);
      this.hitbox = new Rectangle(15, 15, this.size.x - 20, this.size.y - 40);
      this.animSheet = new ld.AnimSheet('assets/shadow3.png', this.size);
      this.addAnim('idle_right', 100, [[0, 0]]);
      this.addAnim('idle_left', 100, [[0, 1]]);
      this.addAnim('run_right', 100, [[0, 0], [1, 0], [2, 0]]);
      this.addAnim('run_left', 100, [[0, 1], [1, 1], [2, 1]]);
      this.setAnim('run_right');
    }

    Shadow3.prototype.update = function() {
      var angle, speed;
      if (this.tracking) {
        angle = this.level.player.pos.getAngle(this.pos);
        speed = this.speed;
        if (this.level.player.pos.getDistance(this.pos) > 150) {
          speed *= 1.6;
        }
        if (this.level.player.pos.getDistance(this.pos) > 20) {
          this.vel.x = Math.cos(angle) * speed;
          this.vel.y = Math.sin(angle) * speed;
        }
      }
      return Shadow3.__super__.update.call(this);
    };

    return Shadow3;

  })(ld.Monster);

  ld.Boss = (function(_super) {
    __extends(Boss, _super);

    function Boss(pos) {
      Boss.__super__.constructor.call(this, ld.ENTITY.BOSS, pos, new Vec2(204, 150), 20, 5, 0);
      this.hitbox = new Rectangle(15, 15, this.size.x - 20, this.size.y - 20);
      this.animSheet = new ld.AnimSheet('assets/boss.png', this.size);
      this.addAnim('idle_right', 100, [[0, 0]]);
      this.addAnim('idle_left', 100, [[0, 1]]);
      this.setAnim('idle_left');
      this.spawnedShadow3 = false;
    }

    Boss.prototype.damage = function() {
      var i, _fn, _i;
      if (this.level.isCleared()) {
        _fn = (function(_this) {
          return function(i) {
            return setTimeout(function() {
              if (i < 49) {
                _this.game.ssx = ~~(Math.random() * 10) - 5;
                return _this.game.ssy = ~~(Math.random() * 10) - 5;
              } else {
                _this.game.ssx = 0;
                return _this.game.ssy = 0;
              }
            }, i * 10);
          };
        })(this);
        for (i = _i = 0; _i < 50; i = ++_i) {
          _fn(i);
        }
        return Boss.__super__.damage.call(this, 1);
      }
    };

    Boss.prototype.die = function() {
      var i, _i, _results;
      this.level.player.setInvicibleFor(5000000);
      _results = [];
      for (i = _i = 0; _i < 500; i = ++_i) {
        _results.push((function(_this) {
          return function(i) {
            return setTimeout(function() {
              if (i < 499) {
                _this.game.ssx = ~~(Math.random() * 50) - 25;
                return _this.game.ssy = ~~(Math.random() * 50) - 25;
              } else {
                _this.game.ssx = 0;
                _this.game.ssy = 0;
                _this.game.stop();
                return ld.setState('congratz');
              }
            }, i * 10);
          };
        })(this)(i));
      }
      return _results;
    };

    Boss.prototype.update = function() {
      var angle, from, monster, projectile;
      if (Date.now() % 150 === 0) {
        from = new Vec2(this.pos.x + this.size.x / 2, this.pos.y + this.size.x / 2);
        angle = this.level.player.pos.getAngle(from);
        projectile = new ld.BossProjectile(from, angle, 5);
        this.level.registerEntity(projectile);
      }
      if (Date.now() % 300 === 0) {
        monster = new ld.Shadow1(new Vec2(40, 21));
        this.level.registerEntity(monster);
      }
      if (Date.now() % 510 === 0) {
        monster = new ld.Shadow2(new Vec2(360, 60));
        this.level.registerEntity(monster);
      }
      if (!this.spawnedShadow3 || Date.now() % 1200 === 0) {
        this.spawnedShadow3 = true;
        monster = new ld.Shadow3(new Vec2(360, 420));
        this.level.registerEntity(monster);
      }
      return Boss.__super__.update.call(this);
    };

    return Boss;

  })(ld.Monster);

  ld.Player = (function(_super) {
    __extends(Player, _super);

    function Player(pos) {
      Player.__super__.constructor.call(this, ld.ENTITY.PLAYER, pos, new Vec2(24, 39), 6);
      this.speed = 4;
      this.hitbox = new Rectangle(0, 10, this.size.x, this.size.y - 20);
      this.animSheet = new ld.AnimSheet('assets/player.png', this.size);
      this.weapon1 = null;
      this.invincibleUntil = new Date(0);
      this.speedBoostUntil = new Date(0);
      this.strengthBoostUntil = new Date(0);
      this.dead = false;
      this.setInvicibleFor(2000);
      this.addAnim('idle_right', 100, [[0, 0]]);
      this.addAnim('idle_left', 100, [[0, 1]]);
      this.addAnim('run_right', 100, [[1, 0], [2, 0], [3, 0], [4, 0]]);
      this.addAnim('run_left', 100, [[1, 1], [2, 1], [3, 1], [4, 1]]);
      this.setAnim('idle_right');
    }

    Player.prototype.strengthBoost = function(ms) {
      return this.strengthBoostUntil = Date.now() + ms;
    };

    Player.prototype.speedBoost = function(ms) {
      return this.speedBoostUntil = Date.now() + ms;
    };

    Player.prototype.setInvicibleFor = function(ms) {
      return this.invincibleUntil = Date.now() + ms;
    };

    Player.prototype.isInvincible = function() {
      return this.invincibleUntil > Date.now();
    };

    Player.prototype.hasStrengthBoost = function() {
      return this.strengthBoostUntil > Date.now();
    };

    Player.prototype.hasSpeedBoost = function() {
      return this.speedBoostUntil > Date.now();
    };

    Player.prototype.damage = function(amount) {
      if (!this.isInvincible()) {
        if (this.hasStrengthBoost) {
          amount = Math.max(0, Math.round(amount * .7));
        }
        Player.__super__.damage.call(this, amount);
        ld.Particle.sendParticles(this.level, 30, this.pos.copy(), ld.PARTICLE.BLOOD);
        return this.setInvicibleFor(2000);
      }
    };

    Player.prototype.die = function() {
      if (!this.dead) {
        this.dead = true;
        return ld.setState('respawn');
      }
    };

    Player.prototype.update = function() {
      var angle;
      angle = this.game.mousePos.getAngle(this.pos);
      if (this.hasSpeedBoost()) {
        this.speed = 6;
        if (Date.now() % 5 === 0) {
          ld.Particle.sendParticles(this.level, 1, new Vec2(this.pos.x, this.pos.y + this.size.y / 2), ld.PARTICLE.SPEED);
        }
      } else {
        this.speed = 4;
      }
      if (this.hasStrengthBoost()) {
        if (Date.now() % 5 === 0) {
          ld.Particle.sendParticles(this.level, 1, new Vec2(this.pos.x, this.pos.y + this.size.y / 2), ld.PARTICLE.STRENGTH);
        }
      }
      if (this.weapon1 != null) {
        if (this.game.keys[ld.KEY.X]) {
          this.weapon1.shoot(angle);
        }
        this.weapon1.pos = this.pos;
      }
      if (this.game.mouseDown && this.game.mousePos.getDistance(this.pos) > this.speed * 5) {
        this.vel.x = Math.cos(angle) * this.speed;
        this.vel.y = Math.sin(angle) * this.speed;
      }
      if (this.game.mousePos.x > this.pos.x) {
        this.orientation = ld.ORIENTATION.RIGHT;
      } else {
        this.orientation = ld.ORIENTATION.LEFT;
      }
      return Player.__super__.update.call(this);
    };

    Player.prototype.draw = function(ctx) {
      if (this.isInvincible() && ~~(Date.now() / 150) % 2 === 0) {
        ctx.globalAlpha = .5;
        Player.__super__.draw.call(this, ctx);
        return ctx.globalAlpha = 1;
      } else {
        return Player.__super__.draw.call(this, ctx);
      }
    };

    return Player;

  })(ld.Character);

  ld.Factory = (function() {
    function Factory() {}

    Factory.weapon = function(kind, pos) {};

    Factory.monster = function(kind, pos) {
      var MonsterClass;
      if (kind === ld.ENTITY.SHADOW1) {
        MonsterClass = ld.Shadow1;
      }
      if (kind === ld.ENTITY.SHADOW2) {
        MonsterClass = ld.Shadow2;
      }
      if (kind === ld.ENTITY.SHADOW3) {
        MonsterClass = ld.Shadow3;
      }
      if (kind === ld.ENTITY.BOSS) {
        MonsterClass = ld.Boss;
      }
      return new MonsterClass(pos);
    };

    Factory.powerup = function(kind, pos) {
      var powerup;
      if (kind >= 60 && kind <= 69) {
        return powerup = new ld.SmallPotion(kind, pos);
      } else if (kind >= 70 && kind <= 79) {
        return powerup = new ld.BigPotion(kind, pos);
      } else if (kind >= 80 && kind <= 89) {
        return powerup = new ld.WeaponLoot(kind, pos);
      } else {
        throw new Error('not a powerup');
      }
    };

    return Factory;

  })();

  ld.Level = (function() {
    function Level(game, id, existingPlayer) {
      var data;
      this.game = game;
      this.id = id;
      this.walls = [];
      this.entities = {};
      this.entityCount = 0;
      this.player = existingPlayer || null;
      data = ld.DATA.levels[id];
      console.log(data);
      this.addWalls(data);
      this.addPowerups(data);
      this.addMonsters(data);
      this.addTeleporters(data);
      if (existingPlayer == null) {
        this.addPlayer(data);
      } else {
        this.player.pos = Vec2.fromArray(data.playerPos);
        this.registerEntity(this.player);
        if (this.player.weapon1 != null) {
          this.registerEntity(this.player.weapon1);
        }
      }
      $('#container').css('background', data.color);
    }

    Level.prototype.isCleared = function() {
      var cleared;
      cleared = true;
      this.forEachMonster(function(monster) {
        cleared = false;
      });
      return cleared;
    };

    Level.prototype.addPlayer = function(data) {
      var pos;
      pos = Vec2.fromArray(data.playerPos);
      this.player = new ld.Player(pos);
      return this.registerEntity(this.player);
    };

    Level.prototype.addTeleporters = function(data) {
      var levelid, pos, size, teleporter, teleporterData, _i, _len, _ref, _results;
      _ref = data.teleporters;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        teleporterData = _ref[_i];
        levelid = teleporterData[0];
        pos = Vec2.fromArray(teleporterData.slice(1, 3));
        size = Vec2.fromArray(teleporterData.slice(3, 5));
        teleporter = new ld.Teleporter(pos, size, levelid);
        _results.push(this.registerEntity(teleporter));
      }
      return _results;
    };

    Level.prototype.addPowerups = function(data) {
      var kind, pos, powerup, powerupData, _i, _len, _ref, _results;
      _ref = data.powerups;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        powerupData = _ref[_i];
        kind = powerupData[0];
        pos = Vec2.fromArray(powerupData.slice(1, 3));
        powerup = ld.Factory.powerup(kind, pos);
        _results.push(this.registerEntity(powerup));
      }
      return _results;
    };

    Level.prototype.addWalls = function(data) {
      var pos, size, wall, wallData, _i, _len, _ref, _results;
      this.registerEntity(new ld.Wall(new Vec2(0, -10), new Vec2(this.game.width, 10)));
      this.registerEntity(new ld.Wall(new Vec2(-10, 0), new Vec2(10, this.game.height)));
      this.registerEntity(new ld.Wall(new Vec2(this.game.width, 0), new Vec2(10, this.game.height)));
      this.registerEntity(new ld.Wall(new Vec2(0, this.game.height), new Vec2(this.game.width, 10)));
      _ref = data.walls;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        wallData = _ref[_i];
        pos = Vec2.fromArray(wallData.slice(0, 2));
        size = Vec2.fromArray(wallData.slice(2, 4));
        wall = new ld.Wall(pos, size);
        _results.push(this.registerEntity(wall));
      }
      return _results;
    };

    Level.prototype.addMonsters = function(data) {
      var kind, monster, monsterData, pos, _i, _len, _ref, _results;
      _ref = data.monsters;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        monsterData = _ref[_i];
        kind = monsterData[0];
        pos = Vec2.fromArray(monsterData.slice(1, 3));
        monster = ld.Factory.monster(kind, pos);
        _results.push(this.registerEntity(monster));
      }
      return _results;
    };

    Level.prototype.forEachProjectile = function(callback) {
      var entity, id, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (id in _ref) {
        entity = _ref[id];
        if (entity.kind >= 30 && entity.kind <= 39) {
          _results.push(callback(entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Level.prototype.forEachMonster = function(callback) {
      var entity, id, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (id in _ref) {
        entity = _ref[id];
        if (entity.kind >= 40 && entity.kind <= 49) {
          _results.push(callback(entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Level.prototype.forEachOfKind = function(kind, callback) {
      var entity, id, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (id in _ref) {
        entity = _ref[id];
        if (entity.kind === kind) {
          _results.push(callback(entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Level.prototype.registerEntity = function(entity) {
      this.entities[++this.entityCount] = entity;
      entity.setGame(this.game);
      entity.setLevel(this);
      return entity.id = this.entityCount;
    };

    Level.prototype.unregisterEntity = function(entity) {
      return delete this.entities[entity.id];
    };

    Level.prototype.drawGuide = function(ctx) {
      ctx.beginPath();
      ctx.moveTo(this.player.pos.x, this.player.pos.y);
      ctx.lineTo(this.game.mousePos.x, this.game.mousePos.y);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(255, 255, 255, .05)';
      return ctx.stroke();
    };

    Level.prototype.tick = function() {
      var entity, id, _ref, _results;
      this.game.ctx.clearRect(0, 0, this.game.width, this.game.height);
      this.drawGuide(this.game.ctx);
      _ref = this.entities;
      _results = [];
      for (id in _ref) {
        entity = _ref[id];
        entity.update();
        _results.push(entity.draw(this.game.ctx));
      }
      return _results;
    };

    return Level;

  })();

  ld.Game = (function() {
    function Game(width, height, ctx) {
      this.width = width;
      this.height = height;
      this.ssx = 0;
      this.ssy = 0;
      this.ctx = ctx;
      this.started = false;
      this.level = null;
      this.keys = {};
      this.mousePos = new Vec2();
      this.mouseDown = false;
      this.loadLevel(1);
    }

    Game.prototype.respawnPlayer = function() {
      var weapon;
      if ((this.level.player == null) || !this.level.player.dead) {
        return console.warn('wtf');
      }
      this.level.player.health = 6;
      this.level.player.dead = false;
      if (this.level.player.weapon1 != null) {
        this.level.player.weapon1.remove();
        this.level.player.weapon1 = null;
      }
      weapon = null;
      ld.setState('game');
      if (this.level.id < 3) {
        this.loadLevel(1);
        weapon = null;
      } else if (this.level.id === 4 || this.level.id === 5 || this.level.id === 6) {
        this.loadLevel(4);
        weapon = new ld.Basicgun();
      } else if (this.level.id === 7 || this.level.id > 7) {
        this.loadLevel(7);
        weapon = new ld.Lasergun();
      } else {
        throw 'should not happen';
      }
      if (weapon != null) {
        this.level.player.weapon1 = weapon;
        return this.level.registerEntity(weapon);
      }
    };

    Game.prototype.loadLevel = function(levelid) {
      var player;
      player = (this.level != null) && this.level.player instanceof ld.Player ? this.level.player : null;
      return this.level = new ld.Level(this, levelid, player);
    };

    Game.prototype.tick = function() {
      if (this.started) {
        if (this.level) {
          this.level.tick();
        }
        return window.requestAnimFrame((function(_this) {
          return function() {
            return _this.tick();
          };
        })(this));
      }
    };

    Game.prototype.start = function() {
      ld.setState('game');
      this.started = true;
      return this.tick();
    };

    Game.prototype.stop = function() {
      return this.started = false;
    };

    return Game;

  })();

  ld.setState = function(state) {
    var $state;
    $state = $('.state#' + state);
    if ($state.length !== 1) {
      throw new Error('state error');
    }
    $('.state').hide();
    $state.show();
    return $('#overlay').show().fadeOut(2000);
  };

  ld.playingIntro = false;

  ld.introCancelled = false;

  ld.playIntro = function() {
    var insertText;
    ld.playingIntro = true;
    insertText = function(text, x, y, lifeTime) {
      var $t;
      $t = $('<div></div>').addClass('text').html(text).css({
        left: x,
        top: y
      }).appendTo('#texts').hide().fadeIn();
      return setTimeout((function(_this) {
        return function() {
          return $t.fadeOut();
        };
      })(this), lifeTime || 1000);
    };
    if (!ld.introCancelled) {
      ld.setState('intro1');
    }
    insertText('Shadow creatures', 420, 70, 20000);
    setTimeout(((function(_this) {
      return function() {
        return insertText('<b>hate light</b>', 420, 100, 20000);
      };
    })(this)), 1000);
    setTimeout(((function(_this) {
      return function() {
        return insertText('so they <b>absorb it</b>', 420, 130, 20000);
      };
    })(this)), 3000);
    setTimeout(((function(_this) {
      return function() {
        return insertText('this planet is about to lose its sun', 50, 430, 20000);
      };
    })(this)), 6000);
    return setTimeout(((function(_this) {
      return function() {
        $('.text').remove();
        if (!ld.introCancelled) {
          ld.setState('intro2');
        }
        setTimeout((function() {
          return insertText('They use <b>monster fuel</b>', 50, 50, 20000);
        }), 1000);
        setTimeout((function() {
          return insertText('They get it from the <b>depths</b> of this planet', 50, 80, 20000);
        }), 3000);
        setTimeout((function() {
          return insertText('If they get enough of it', 50, 130, 20000);
        }), 5000);
        setTimeout((function() {
          return insertText('the sun will die', 360, 130, 20000);
        }), 7000);
        setTimeout((function() {
          return insertText('and the planet too', 360, 160, 20000);
        }), 9000);
        setTimeout((function() {
          return insertText('which would be a little sad', 360, 190, 20000);
        }), 10000);
        setTimeout((function() {
          return insertText('<b>you go first :)</b>', 150, 320, 20000);
        }), 12000);
        return setTimeout((function() {
          return insertText('Press X', 150, 350, 20000);
        }), 12000);
      };
    })(this)), 12000);
  };

  $(function() {
    var canvas, game;
    canvas = document.getElementById('game');
    game = new ld.Game(800, 500, canvas.getContext('2d'));
    ld.playIntro();
    $('#respawn').click((function(_this) {
      return function() {
        return game.respawnPlayer();
      };
    })(this));
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === ld.KEY.X && ld.playingIntro) {
        ld.playingIntro = false;
        ld.introCancelled = true;
        $('#texts').hide();
        ld.setState('game');
        game.start();
      }
      if (~[40, 38, 32].indexOf(e.keyCode)) {
        e.preventDefault();
      }
      return game.keys[e.keyCode] = true;
    });
    document.addEventListener('keyup', function(e) {
      return delete game.keys[e.keyCode];
    });
    document.addEventListener('mousemove', function(e) {
      return game.mousePos = new Vec2(e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop);
    });
    document.addEventListener('mousedown', function(e) {
      return game.mouseDown = true;
    });
    document.addEventListener('mouseup', function(e) {
      return game.mouseDown = false;
    });
    if (ld.DEBUG) {
      document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        return gm.level.player.pos = gm.mousePos.copy();
      });
    }
    return window.gm = game;
  });

}).call(this);
